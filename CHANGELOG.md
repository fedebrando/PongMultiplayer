Nella prima tabella si riportano le funzionalità implementate nell'applicazione, mentre nella seconda i bug corretti.

# Funzionalità

| **Feature** | **Descrizione**
|------------------------|-----------------------------------------|
| Page style customization | - |
| Other feedback messages | - [INFO] Welcome<br>- [SUCCESS] Connection established<br>- [INFO] Move player with arrows or WASD (for playing)<br>- [INFO] Ready to start (for playing)<br>- [INFO] Enjoy the game (for watching)<br>- [WARNING] You can't select a team unless you firstly select your player ID<br>- [WARNING] You can't press connection button unless you firstly choose the game ID<br>- [WARNING] You can't choose settings for an existing game |
| Playfield visualization after game id entered | - |
| Player team selection | - |
| Decreasing player size by count | La dimensione del player viene divisa per il numero di giocatori presenti nel suo team (i controlli nei movimenti sono stati estesi sia sul frontend che sul backend) |
| Laser beam of the ball segment | - |
| Goal animation on ball and winner players | Al Goal, la pallina lampeggia del colore del team vincente, così come il bordo dei giocatori (un alone sottile del colore del team) |
| Goal animated banner | Al Goal, al posto del punteggio compare la scritta 'GOOOOOOL!' del colore del team vincente con un'animazione di pulsazione |
| Local storage | GameId, PlayeId e Team vengono memorizzati localmente e riproposti alla nuova riapertura della pagina (la scrittura avviene subito dopo la pressione del pulsante di connessione) |
| Playfield autofocus | Focus automatico sull'area di gioco all'ingresso di un nuovo giocatore |
| Settings panel | Pannello per la personalizzazione della partita (in caso di partita già esistente, le configurazioni non hanno alcun effetto) con cheking dei valori sia sul client che sul server, dove è presente un'apposita classe per la gestione delle personalizzazioni (GameDataSettings), che sul client è una semplice interfaccia. Le personalizzazioni possibili sono le seguenti.<br>- Larghezza dell'area di gioco<br>- Altezza dell'area di gioco<br>- Altezza del giocatore<br>- Diametro della pallina<br>- Velocità della pallina<br>- Velocità del giocatore |
| Loading phase | Icona di caricamento con disabilitazione del form evitando più richieste successive al server |
| Game search API endpoint | Endpoint REST pubblico per sapere in anticipo se un gameId digitato è relativo a un gioco già esistente o se è nuovo |
| On playing games API endpoint | Endpoint REST pubblico per ottenere un determinato numero di gameId per potersi iscrivere a una partita esistente (per evitare inefficienza lato server si è deciso di utilizzare l'interfaccia Pageable, che permette di ottenere già il numero richiesto di game direttamente dal repository). Gli identificativi dei game visualizzati NON sono necessariamente quelli più recentemente creati (lato server, dentro GameData ho deciso volontariamente di lasciare il campo 'created_at' per uno sviluppo futuro in cui i giochi vengano ordinati secondo il timestamp di creazione, consentendo di prendere i giochi più recenti) |
| Existing games circular progress loading | Simbolo del caricamento circolare prima che le partite esistenti vengano visualizzate |
| Real-time existing game updating | Aggiornamento automatico delle partite esistenti ogni 10 secondi |
| Player search API endpoint | Endpoint REST pubblico per sapere in anticipo se il player ID esiste già (in presenza di game già esistente) |
| Game settings button with rotating icon | Quando abilitato, passando sopra al pulsante che apre il pannello di personalizzazione della partita, l'icona della ruota dentata compie una rotazione di 360 gradi attorno al suo centro, per poi tornare alla posizione di partenza con una rotazione inversa dopo aver tolto il cursore |
| Disconnect | Quando lo ritiene opportuno, un giocatore può uscire da un game premendo l'apposito pulsante 'Quit' posto sotto l'area di gioco (o ricaricando brutalmente la pagina, innescando l'evento 'beforeunload'); in questo caso il player viene cancellato dalla partita. Se quello è l'unico giocatore presente dentro il game, quest'ultimo viene cancellato dal repository. |
| Game ID as written on play field | L'identificativo del game è riportato sul campo da gioco in filigrana |

# Bug sistemati

| **Bug** | **Descrizione** | **Correzione**
|------------------------|-----------------------------------------|--------------|
| Firefox animation bug | Su Firefox la pallina ha comportamenti anomali legati all'animazione | Aggiunta di 'px' all'impostazione delle coordinate finali per l'animazione della pallina |
| Firefox labels bug | Su Firefox le etichette dei giocatori non sono visibili | L'elemento 'foreignObject' deve avere altezza e larghezza positive per poter fare da punto di riferimento (in alto a sinistra) all'etichetta del giocatore |
| Right label transform (and margin) bug | L'etichetta dei giocatori appartenenti al team di destra si comportano in modo anomalo rispetto a quelle di sinistra; in particolare la distanza dal giocatore aumenta all'aumentare della lunghezza del testo dell'etichetta. Questo comportamento è dovuto alla trasformazione applicata nella costante PLAYER_TEXT_RIGHT_TEAM_STYLE, che trasla verso destra l'etichetta della sua lunghezza rispetto al riferimento del foreignObject | La trasformazione è stata modificata in translate(0%, -50%). Tuttavia, anche dopo questa modifica l'etichetta NON ha una distanza dal giocatore pari a quella di sinistra (problema dovuto alla presenza di un margine non nullo attorno al testo); per questa ragione si è aggiunto a PLAYER_TEXT_BASE_STYLE un margine nullo |
| Infite key pressing | Tenendo premuto uno dei tasti per il movimento del giocatore, se si toglie il focus all'area di gioco il giocatore continua ad avanzare, anche se si rilascia il tasto | Impostazione della direzione del giocatore a HOLD nel caso in cui l'area di gioco perda il focus |
| Ball-player collision | Nella determinazione degli effetti di un'eventuale collisione pallina-giocatore si scansionano tutti i giocatori e si prende la prima collisione individuata. In un'ipotetica situazione in cui due giocatori dello stesso team si posizionano per formare "un'asta unica", la pallina potrebbe colpire l'angolo di uno dei due giocatori, provocando un cambio di direzione di quest'ultima | La verifica della collisione viene testata solo con il giocatore (del team in questione) più vicino alla pallina (minimo valore assoluto della differenza delle ordinate) |
| Player provisional subscription | Se il giocatore G1 accede a un game con un proprio id e successivamente il giocatore G2 accede allo stesso game con lo stesso id del giocatore G1, che si sta muovendo, allora G2 visualizza l'area di gioco, anche se riceve il messaggio di errore per l'id già esistente (dovuto alla temporanea subscription di G2 al topic del game) | Introduzione di un ulteriore messaggio per consentire l'ingresso in partita (GAME_AVAILABLE) e la visualizzazione dell'area di gioco |
| sendStart() for watching | Alla pressione del tasto 'Enter' l'invio del messaggio di Start avviene anche in modalità 'spettatore', causando un'eccezione non gestita sul server (lanciata dalla funzione privata retrievePlayer()) | Evitata la chiamata a sendStart() nella modalità spettatore (playerId === '' o anche playerId == false) |
| Watchers don't see Goal animations | Quando una squadra segna, gli eventuali client spettatori non vedono alcuna animazione perché non ricevono il messaggio di informazione con codice POINT_SCORED, riservato ai soli giocatori | Gestione lato client: gli spettatori si accorgono da soli quando un team segna, senza una segnalazione dal server |
| Unsubscribe from an unexisting topic | Quando si riceve un qualunque messaggio di errore, la pagina non risponde ai comandi | Dopo 2 secondi dalla visualizzazione del messaggio di errore, la pagina viene ricaricata |
| Ball animation stop | Se all'invio dei messaggi di fine animazione da parte dei client player tutti i giocatori non rispettano la condizione nel sorgente GameDataBroker.java (ballAnimation.getEndTimestamp() <= System.currentTimeMillis()), i giocatori si portano in una situazione di stallo, in attesa della nuova animazione da parte del server, che non arriverà mai, a meno che non faccia irruzione un nuovo giocatore. La probabilità che una tale condizione di stallo si verifichi diminuisce all'aumentare del numero di giocatori nella partita (inoltre il problema sembra dovuto anche alla messaggistica...) | Per prevenire questo effetto (che non dovrebbe verificarsi) in primo luogo si può aggiungere una quantità sufficientemente grande al secondo membro della disuguaglianza (MAX_LATENCY = 100ms) |
